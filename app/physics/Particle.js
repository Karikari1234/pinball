// Generated by CoffeeScript 1.7.1

/*
Particle Physics

@author Anderson Freitas
 */
var Particle;

Particle = (function() {
  function Particle(sphere, mass) {
    this.sphere = sphere;
    this.mass = mass;
    this.radius = this.sphere.radius;
    this.A = Ï€ * this.radius * this.radius / 10000;
    this.rho = 1.225;
    this.Cd = 0.47;
    this.velocity = vec3.create();
    this.forces = vec3.create();
    this.speed = 0;
    this.colliding = false;
    this.impactForces;
    this.acceleration = vec3.create();
  }

  Particle.prototype.applyForce = function(force) {
    var Fd, drag, vel_sq2;
    this.forces = vec3.create();
    if (this.colliding) {
      return vec3.add(this.forces, this.forces, this.impactForces);
    } else {
      vel_sq2 = vec3.mul(vec3.create(), this.velocity, this.velocity);
      Fd = 0.5 * this.Cd * this.A * this.rho;
      drag = vec3.scale(vec3.create(), vel_sq2, Fd);
      vec3.normalize(drag, drag);
      vec3.add(this.forces, this.forces, force);
      return vec3.add(this.forces, this.forces, drag);
    }
  };

  Particle.prototype.applyFriction = function(coeff) {};

  Particle.prototype.checkForCollisions = function(dt, staticWorld, particles) {
    var Fi, collidingFace, direction, distance, impulse, obstacle, particle, pos, r, relative_velocity, separation, vrn, _i, _j, _len, _len1, _results;
    direction = vec3.create();
    relative_velocity = vec3.create();
    vrn = 0.0;
    impulse = 0.0;
    Fi = vec3.create();
    this.colliding = false;
    this.impactForces = vec3.create();
    for (_i = 0, _len = staticWorld.length; _i < _len; _i++) {
      obstacle = staticWorld[_i];
      if (!obstacle.adjusted) {
        obstacle.adjusted = true;
        _.each(obstacle.faces, function(face, i) {
          return _.each(face.mesh, function(vec, j) {
            return obstacle.faces[i].mesh[j] = add(vec, obstacle.position);
          });
        });
      }
      collidingFace = Collision.testSphereAgainstFaces(this.sphere, obstacle.faces);
      if (collidingFace.collision) {
        direction = collidingFace.normal;
        relative_velocity = this.velocity;
        vrn = vec3.dot(relative_velocity, direction);
        if (vrn < 0.0) {
          impulse = -vrn * (0.7 + 1) / (1 / this.mass);
          Fi = vec3.clone(direction);
          vec3.scale(Fi, Fi, impulse / dt);
          vec3.add(this.impactForces, this.impactForces, Fi);
          this.colliding = true;
          audio.effects.chomp.sing();
          addScore();
          break;
        }
      }
    }
    _results = [];
    for (_j = 0, _len1 = particles.length; _j < _len1; _j++) {
      particle = particles[_j];
      r = this.radius + particle.radius;
      distance = vec3.create();
      vec3.sub(distance, this.sphere.position, particle.sphere.position);
      separation = vec3.length(distance) - r;
      if (separation <= 0.0) {
        vec3.normalize(distance, distance);
        direction = distance;
        vec3.sub(relative_velocity, this.velocity, particle.velocity);
        vrn = vec3.dot(relative_velocity, direction);
        if (vrn < 0.0) {
          impulse = -vrn * (0.6 + 1) / (1 / this.mass + 1 / particle.mass);
          Fi = vec3.clone(direction);
          vec3.scale(Fi, Fi, impulse / dt);
          vec3.add(this.impactForces, this.impactForces, Fi);
          pos = vec3.create();
          vec3.scale(pos, direction, separation);
          vec3.sub(this.sphere.position, this.sphere.position, pos);
          _results.push(this.colliding = true);
        } else {
          _results.push(void 0);
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Particle.prototype.updateEuler = function(dt) {
    var acceleration, ds, dv;
    acceleration = vec3.create();
    dv = vec3.create();
    ds = vec3.create();
    vec3.scale(acceleration, this.forces, 1 / this.mass);
    vec3.scale(dv, acceleration, dt);
    vec3.add(this.velocity, this.velocity, dv);
    vec3.scale(ds, this.velocity, dt);
    vec3.add(this.sphere.position, this.sphere.position, ds);
    return this.speed = vec3.length(this.velocity);
  };

  Particle.prototype.updateVerlet = function(dt) {
    var last_acceleration, new_acceleration, new_pos;
    last_acceleration = this.acceleration;
    new_pos = add(scale(this.velocity, dt), scale(last_acceleration, dt * dt * 0.5));
    vec3.add(this.sphere.position, this.sphere.position, new_pos);
    new_acceleration = scale(this.forces, 1 / this.mass);
    this.acceleration = scale(add(last_acceleration, new_acceleration), 0.5);
    return this.velocity = add(this.velocity, scale(this.acceleration, dt));
  };

  Particle.prototype.current_force = function(position, velocity) {
    var Fd, drag, forces, gravity, vel_sq2;
    forces = vec3.create();
    if (this.colliding) {
      vec3.add(forces, forces, this.impactForces);
    }
    vel_sq2 = vec3.mul(vec3.create(), velocity, velocity);
    Fd = 0.5 * this.Cd * this.A * this.rho;
    drag = scale(vel_sq2, Fd);
    vec3.normalize(drag, drag);
    gravity = vec3.fromValues(0, 0, -9.81);
    forces = add(forces, gravity);
    forces = add(forces, drag);
    forces = scale(forces, 1 / this.mass);
    return forces;
  };

  Particle.prototype.updateRK4 = function(dt) {
    var midVelocity, pos, vk1, vk2, vk3, vk4, xk1, xk2, xk3, xk4;
    pos = this.sphere.position;
    this.acceleration = this.current_force(pos, this.velocity);
    xk1 = scale(this.velocity, dt);
    vk1 = scale(this.acceleration, dt);
    midVelocity = add(this.velocity, scale(vk1, 0.5));
    xk2 = scale(midVelocity, dt);
    vk2 = scale(scale(this.current_force(add(pos, scale(xk1, 0.5)), midVelocity), 1 / this.mass), dt);
    midVelocity = add(this.velocity, scale(vk2, 0.5));
    xk3 = scale(midVelocity, dt);
    vk3 = scale(scale(this.current_force(add(pos, scale(xk2, 0.5)), midVelocity), 1 / this.mass), dt);
    midVelocity = add(this.velocity, vk3);
    xk4 = scale(midVelocity, dt);
    vk4 = scale(scale(this.current_force(add(pos, xk3), midVelocity), 1 / this.mass), dt);
    this.sphere.position = add(this.sphere.position, scale(add(add(xk1, scale(xk2, 2.0)), add(xk4, scale(xk3, 2.0))), 1 / 6));
    return this.velocity = add(this.velocity, scale(add(add(vk1, scale(vk2, 2.0)), add(vk4, scale(vk3, 2.0))), 1 / 6));
  };

  return Particle;

})();

window.RigidBody = Particle;

//# sourceMappingURL=Particle.map
