// Generated by CoffeeScript 1.7.1

/*
Particle Physics

@author Anderson Freitas
 */

(function() {
  var Particle;

  Particle = (function() {
    var AIR_DENSITY;

    AIR_DENSITY = 1.225;

    function Particle(renderable, mass, radius) {
      this.renderable = renderable;
      this.mass = mass;
      this.radius = radius;
      this.renderable;
      this.mass;
      this.radius;
      this.velocity = vec3.create();
      this.forces = vec3.create();
      this.speed = 0;
      this.colliding = false;
      this.impactForces;
      this.previousPosition;
    }

    Particle.prototype.applyForce = function(force) {
      var drag, fDrag;
      this.forces = vec3.create();
      if (this.colliding) {
        return vec3.add(this.forces, this.forces, this.impactForces);
      } else {
        vec3.add(this.forces, this.forces, force);
        drag = vec3.create();
        vec3.negate(drag, this.velocity);
        vec3.normalize(drag, drag);
        fDrag = 0.5 * AIR_DENSITY * this.speed * (2 * Ï€) * (this.radius * this.radius) * 0.7;
        vec3.scale(drag, drag, fDrag);
        return vec3.add(this.forces, this.forces, drag);
      }
    };

    Particle.prototype.applyFriction = function(coeff) {};

    Particle.prototype.checkForCollisions = function(dt, particles) {
      var Fi, direction, distance, impulse, particle, pos, r, relative_velocity, separation, vrn, _i, _len, _results;
      direction = vec3.create();
      relative_velocity = vec3.create();
      vrn = 0.0;
      impulse = 0.0;
      Fi = vec3.create();
      this.colliding = false;
      this.impactForces = vec3.create();
      if (this.renderable.position[1] <= this.radius) {
        direction = vec3.fromValues(0, 1, 0);
        relative_velocity = this.velocity;
        vrn = vec3.dot(relative_velocity, direction);
        if (vrn < 0.0) {
          impulse = -vrn * (0.60 + 1) / (1 / this.mass);
          Fi = vec3.clone(direction);
          vec3.scale(Fi, Fi, impulse / dt);
          vec3.add(this.impactForces, this.impactForces, Fi);
          this.renderable.position[1] = this.radius;
          this.colliding = true;
        }
      }
      _results = [];
      for (_i = 0, _len = particles.length; _i < _len; _i++) {
        particle = particles[_i];
        r = this.radius + particle.radius;
        distance = vec3.create();
        vec3.sub(distance, this.renderable.position, particle.renderable.position);
        separation = vec3.length(distance) - r;
        if (separation <= 0.0) {
          vec3.normalize(distance, distance);
          direction = distance;
          vec3.sub(relative_velocity, this.velocity, particle.velocity);
          vrn = vec3.dot(relative_velocity, direction);
          if (vrn < 0.0) {
            impulse = -vrn * (0.6 + 1) / (1 / this.mass + 1 / particle.mass);
            Fi = vec3.clone(direction);
            vec3.scale(Fi, Fi, impulse / dt);
            vec3.add(this.impactForces, this.impactForces, Fi);
            pos = vec3.create();
            vec3.scale(pos, direction, separation);
            vec3.sub(this.renderable.position, this.renderable.position, pos);
            _results.push(this.colliding = true);
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };


    /*
    dt = time step
     */

    Particle.prototype.update = function(dt) {
      var acceleration, ds, dv;
      acceleration = vec3.create();
      dv = vec3.create();
      ds = vec3.create();
      vec3.scale(acceleration, this.forces, 1 / this.mass);
      vec3.scale(dv, acceleration, dt);
      vec3.add(this.velocity, this.velocity, dv);
      vec3.scale(ds, this.velocity, dt);
      vec3.add(this.renderable.position, this.renderable.position, ds);
      return this.speed = vec3.length(this.velocity);
    };

    return Particle;

  })();

  window.RigidBody = Particle;

}).call(this);

//# sourceMappingURL=Particle.map
