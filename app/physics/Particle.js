// Generated by CoffeeScript 1.7.1

/*
Particle Physics

@author Anderson Freitas
 */
var Particle;

Particle = (function() {
  function Particle(sphere, mass) {
    this.sphere = sphere;
    this.mass = mass;
    this.radius = this.sphere.radius;
    this.A = Ï€ * this.radius * this.radius / 10000;
    this.rho = 1.225;
    this.Cd = 0.47;
    this.velocity = vec3.create();
    this.forces = vec3.create();
    this.speed = 0;
    this.colliding = false;
    this.impactForces;
  }

  Particle.prototype.applyForce = function(force) {
    var Fd, drag, vel_sq2;
    this.forces = vec3.create();
    if (this.colliding) {
      return vec3.add(this.forces, this.forces, this.impactForces);
    } else {
      vel_sq2 = vec3.mul(vec3.create(), this.velocity, this.velocity);
      Fd = 0.5 * this.Cd * this.A * this.rho;
      drag = vec3.scale(vec3.create(), vel_sq2, Fd);
      vec3.normalize(drag, drag);
      vec3.add(this.forces, this.forces, force);
      return vec3.add(this.forces, this.forces, drag);
    }
  };

  Particle.prototype.applyFriction = function(coeff) {};

  Particle.prototype.checkForCollisions = function(dt, staticWorld, particles) {
    var Fi, collidingFace, direction, distance, impulse, obstacle, particle, pos, r, relative_velocity, separation, vrn, _i, _j, _len, _len1, _results;
    direction = vec3.create();
    relative_velocity = vec3.create();
    vrn = 0.0;
    impulse = 0.0;
    Fi = vec3.create();
    this.colliding = false;
    this.impactForces = vec3.create();
    for (_i = 0, _len = staticWorld.length; _i < _len; _i++) {
      obstacle = staticWorld[_i];
      if (!obstacle.adjusted) {
        obstacle.adjusted = true;
        _.each(obstacle.faces, function(face, i) {
          return _.each(face.mesh, function(vec, j) {
            return obstacle.faces[i].mesh[j] = add(vec, obstacle.position);
          });
        });
      }
      collidingFace = Collision.testSphereAgainstFaces(this.sphere, obstacle.faces);
      if (collidingFace.collision) {
        direction = collidingFace.normal;
        relative_velocity = this.velocity;
        vrn = vec3.dot(relative_velocity, direction);
        if (vrn < 0.0) {
          impulse = -vrn * (0.7 + 1) / (1 / this.mass);
          Fi = vec3.clone(direction);
          vec3.scale(Fi, Fi, impulse / dt);
          vec3.add(this.impactForces, this.impactForces, Fi);
          this.colliding = true;
          break;
        }
      }
    }
    _results = [];
    for (_j = 0, _len1 = particles.length; _j < _len1; _j++) {
      particle = particles[_j];
      r = this.radius + particle.radius;
      distance = vec3.create();
      vec3.sub(distance, this.sphere.position, particle.sphere.position);
      separation = vec3.length(distance) - r;
      if (separation <= 0.0) {
        vec3.normalize(distance, distance);
        direction = distance;
        vec3.sub(relative_velocity, this.velocity, particle.velocity);
        vrn = vec3.dot(relative_velocity, direction);
        if (vrn < 0.0) {
          impulse = -vrn * (0.6 + 1) / (1 / this.mass + 1 / particle.mass);
          Fi = vec3.clone(direction);
          vec3.scale(Fi, Fi, impulse / dt);
          vec3.add(this.impactForces, this.impactForces, Fi);
          pos = vec3.create();
          vec3.scale(pos, direction, separation);
          vec3.sub(this.sphere.position, this.sphere.position, pos);
          _results.push(this.colliding = true);
        } else {
          _results.push(void 0);
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };


  /*
  dt = time step
   */

  Particle.prototype.update = function(dt) {
    var acceleration, ds, dv;
    acceleration = vec3.create();
    dv = vec3.create();
    ds = vec3.create();
    vec3.scale(acceleration, this.forces, 1 / this.mass);
    vec3.scale(dv, acceleration, dt);
    vec3.add(this.velocity, this.velocity, dv);
    vec3.scale(ds, this.velocity, dt);
    vec3.add(this.sphere.position, this.sphere.position, ds);
    return this.speed = vec3.length(this.velocity);
  };

  return Particle;

})();

window.RigidBody = Particle;

//# sourceMappingURL=Particle.map
